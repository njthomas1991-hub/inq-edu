{% load static %}
<!-- Navbar Avatar Icon Component -->
<div id="navbarAvatarIcon" style="display: inline-block; vertical-align: middle; margin-right: 8px; border-radius: 50%; overflow: hidden; width: 40px; height: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
    <!-- Avatar will render here -->
</div>

<script>
// Full MonsterRenderer class - same as dashboard avatar
class NavbarMonsterRenderer {
    constructor(app, width = 300, height = 400) {
        this.app = app;
        this.width = width;
        this.height = height;
        this.monster = new PIXI.Container();
        this.app.stage.addChild(this.monster);
    }
    
    async init(container, width = 300, height = 400) {
        this.width = width;
        this.height = height;
        // App is already initialized via constructor with config
        const canvas = this.app.canvas || this.app.view;
        if (!canvas) {
            throw new Error('Could not get canvas from PIXI app');
        }
        container.appendChild(canvas);
        
        // Set canvas size attributes
        canvas.width = width;
        canvas.height = height;
        
        // Ensure canvas is properly sized with CSS
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.display = 'block';
        
        return this;
    }

    drawBody(type, color) {
        const graphics = new PIXI.Graphics();
        const safeColor = color || '#FF6B9D';
        graphics.beginFill(parseInt(safeColor.replace('#', ''), 16));
        
        const centerX = this.width / 2;
        const centerY = this.height / 2;

        switch(type) {
            case 'blob':
                graphics.moveTo(centerX, centerY - 80);
                graphics.bezierCurveTo(centerX + 90, centerY - 70, centerX + 100, centerY + 20, centerX + 80, centerY + 90);
                graphics.bezierCurveTo(centerX + 50, centerY + 110, centerX - 50, centerY + 110, centerX - 80, centerY + 90);
                graphics.bezierCurveTo(centerX - 100, centerY + 20, centerX - 90, centerY - 70, centerX, centerY - 80);
                break;
            case 'round':
                graphics.drawCircle(centerX, centerY, 90);
                break;
            case 'tall':
                graphics.drawEllipse(centerX, centerY, 60, 110);
                break;
            case 'wide':
                graphics.drawEllipse(centerX, centerY, 110, 70);
                break;
            case 'pear':
                graphics.moveTo(centerX, centerY - 70);
                graphics.bezierCurveTo(centerX + 60, centerY - 60, centerX + 70, centerY, centerX + 90, centerY + 60);
                graphics.bezierCurveTo(centerX + 80, centerY + 100, centerX - 80, centerY + 100, centerX - 90, centerY + 60);
                graphics.bezierCurveTo(centerX - 70, centerY, centerX - 60, centerY - 60, centerX, centerY - 70);
                break;
            case 'bean':
                graphics.moveTo(centerX - 20, centerY - 90);
                graphics.bezierCurveTo(centerX + 70, centerY - 80, centerX + 80, centerY - 20, centerX + 60, centerY + 50);
                graphics.bezierCurveTo(centerX + 50, centerY + 90, centerX - 50, centerY + 90, centerX - 60, centerY + 50);
                graphics.bezierCurveTo(centerX - 80, centerY - 20, centerX - 70, centerY - 80, centerX - 20, centerY - 90);
                break;
        }
        graphics.endFill();
        return graphics;
    }

    drawPattern(bodyType, patternType, patternColor) {
        if (patternType === 'solid') return null;
        const graphics = new PIXI.Graphics();
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const safeColor = patternColor || '#FF1493';
        const color = parseInt(safeColor.replace('#', ''), 16);

        if (patternType === 'spots') {
            graphics.beginFill(color, 0.4);
            graphics.drawCircle(centerX - 30, centerY - 20, 15);
            graphics.drawCircle(centerX + 40, centerY - 10, 20);
            graphics.drawCircle(centerX - 20, centerY + 30, 18);
            graphics.drawCircle(centerX + 20, centerY + 40, 12);
            graphics.endFill();
        } else if (patternType === 'stripes') {
            graphics.beginFill(color, 0.3);
            for (let i = -80; i < 80; i += 30) {
                graphics.drawRect(centerX - 100, centerY + i, 200, 15);
            }
            graphics.endFill();
        } else if (patternType === 'gradient') {
            graphics.beginFill(color, 0.15);
            graphics.drawCircle(centerX, centerY - 50, 60);
            graphics.endFill();
            graphics.beginFill(color, 0.1);
            graphics.drawCircle(centerX, centerY, 80);
            graphics.endFill();
            graphics.beginFill(color, 0.05);
            graphics.drawCircle(centerX, centerY + 40, 70);
            graphics.endFill();
        }
        return graphics;
    }

    drawEyes(type) {
        const container = new PIXI.Container();
        const centerX = this.width / 2;
        const centerY = this.height / 2;

        if (type === 'one_eye') {
            const eye = this.createEye(60, 60);
            eye.x = centerX;
            eye.y = centerY - 20;
            container.addChild(eye);
        } else if (type === 'big_round') {
            const leftEye = this.createEye(50, 50);
            leftEye.x = centerX - 40;
            leftEye.y = centerY - 30;
            const rightEye = this.createEye(50, 50);
            rightEye.x = centerX + 40;
            rightEye.y = centerY - 30;
            container.addChild(leftEye, rightEye);
        } else if (type === 'small_dots') {
            const leftEye = this.createEye(20, 20);
            leftEye.x = centerX - 30;
            leftEye.y = centerY - 20;
            const rightEye = this.createEye(20, 20);
            rightEye.x = centerX + 30;
            rightEye.y = centerY - 20;
            container.addChild(leftEye, rightEye);
        } else if (type === 'sleepy') {
            const leftEye = this.createSleepyEye();
            leftEye.x = centerX - 35;
            leftEye.y = centerY - 25;
            const rightEye = this.createSleepyEye();
            rightEye.x = centerX + 35;
            rightEye.y = centerY - 25;
            container.addChild(leftEye, rightEye);
        } else if (type === 'googly') {
            const leftEye = this.createGooglyEye();
            leftEye.x = centerX - 40;
            leftEye.y = centerY - 30;
            const rightEye = this.createGooglyEye();
            rightEye.x = centerX + 40;
            rightEye.y = centerY - 30;
            container.addChild(leftEye, rightEye);
        } else if (type === 'angry') {
            const leftEye = this.createAngryEye();
            leftEye.x = centerX - 40;
            leftEye.y = centerY - 30;
            const rightEye = this.createAngryEye();
            rightEye.x = centerX + 40;
            rightEye.y = centerY - 30;
            container.addChild(leftEye, rightEye);
        }
        return container;
    }

    createEye(width, height) {
        const eye = new PIXI.Graphics();
        eye.beginFill(0xFFFFFF);
        eye.drawEllipse(0, 0, width / 2, height / 2);
        eye.endFill();
        eye.beginFill(0x000000);
        eye.drawEllipse(0, 3, width / 5, height / 5);
        eye.endFill();
        return eye;
    }

    createSleepyEye() {
        const eye = new PIXI.Graphics();
        eye.beginFill(0x000000);
        eye.drawRect(-15, -5, 30, 8);
        eye.endFill();
        return eye;
    }

    createGooglyEye() {
        const outerEye = new PIXI.Graphics();
        outerEye.beginFill(0xFFFFFF);
        outerEye.drawCircle(0, 0, 20);
        outerEye.endFill();
        outerEye.beginFill(0x000000);
        outerEye.drawCircle(5, 5, 8);
        outerEye.endFill();
        return outerEye;
    }

    createAngryEye() {
        const eye = new PIXI.Graphics();
        eye.beginFill(0xFFFFFF);
        eye.drawRect(-18, -8, 36, 16);
        eye.endFill();
        eye.beginFill(0x000000);
        eye.drawEllipse(-5, -2, 8, 6);
        eye.drawEllipse(5, -2, 8, 6);
        eye.endFill();
        eye.lineStyle(2, 0x000000);
        eye.moveTo(-15, -15);
        eye.lineTo(-5, -8);
        eye.moveTo(5, -8);
        eye.lineTo(15, -15);
        return eye;
    }

    drawMouth(type) {
        const graphics = new PIXI.Graphics();
        const centerX = this.width / 2;
        const centerY = this.height / 2;

        if (type === 'happy') {
            graphics.lineStyle(3, 0x000000);
            graphics.arc(centerX, centerY + 30, 30, Math.PI * 0, Math.PI);
        } else if (type === 'toothy') {
            graphics.beginFill(0xFFFFFF);
            graphics.drawRect(centerX - 30, centerY + 20, 60, 25);
            graphics.endFill();
            graphics.lineStyle(2, 0x000000);
            for (let i = 0; i < 5; i++) {
                graphics.moveTo(centerX - 20 + i * 10, centerY + 20);
                graphics.lineTo(centerX - 20 + i * 10, centerY + 45);
            }
            graphics.moveTo(centerX - 30, centerY + 45);
            graphics.lineTo(centerX + 30, centerY + 45);
        } else if (type === 'small') {
            graphics.beginFill(0x000000);
            graphics.drawCircle(centerX, centerY + 40, 8);
            graphics.endFill();
        } else if (type === 'big_smile') {
            graphics.lineStyle(4, 0x000000);
            graphics.arc(centerX, centerY + 35, 40, Math.PI * 0, Math.PI);
        } else if (type === 'oh') {
            graphics.beginFill(0x000000);
            graphics.drawCircle(centerX, centerY + 40, 15);
            graphics.endFill();
        } else if (type === 'silly') {
            graphics.beginFill(0xFF0000);
            graphics.drawRect(centerX - 25, centerY + 30, 50, 20);
            graphics.endFill();
            graphics.lineStyle(2, 0x000000);
            graphics.moveTo(centerX, centerY + 30);
            graphics.lineTo(centerX, centerY + 50);
        }
        return graphics;
    }

    drawDecoration(type, color) {
        if (type === 'none') return null;
        
        const graphics = new PIXI.Graphics();
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const moveY = centerY - 100;
        const safeColor = color || '#FFB347';
        graphics.beginFill(parseInt(safeColor.replace('#', ''), 16));

        if (type === 'horns') {
            graphics.drawRect(centerX - 50, moveY - 10, 15, 25);
            graphics.drawRect(centerX + 35, moveY - 10, 15, 25);
        } else if (type === 'antennae') {
            graphics.lineStyle(5, parseInt(safeColor.replace('#', ''), 16));
            graphics.moveTo(centerX - 30, moveY);
            graphics.lineTo(centerX - 40, moveY - 50);
            graphics.moveTo(centerX + 30, moveY);
            graphics.lineTo(centerX + 40, moveY - 50);
            graphics.beginFill(parseInt(safeColor.replace('#', ''), 16));
            graphics.drawCircle(centerX - 40, moveY - 50, 8);
            graphics.drawCircle(centerX + 40, moveY - 50, 8);
        } else if (type === 'spikes') {
            for (let i = -40; i < 40; i += 15) {
                graphics.moveTo(centerX + i, moveY);
                graphics.lineTo(centerX + i - 5, moveY - 20);
                graphics.lineTo(centerX + i + 5, moveY);
            }
        } else if (type === 'ears') {
            graphics.drawEllipse(centerX - 55, moveY + 20, 18, 35);
            graphics.drawEllipse(centerX + 55, moveY + 20, 18, 35);
        } else if (type === 'mohawk') {
            for (let i = -40; i <= 40; i += 15) {
                graphics.moveTo(centerX + i - 6, moveY);
                graphics.lineTo(centerX + i, moveY - 30);
                graphics.lineTo(centerX + i + 6, moveY);
            }
        }
        graphics.endFill();
        return graphics;
    }

    drawArms() {
        return new PIXI.Container();
    }

    render(avatarData) {
        this.monster.removeChildren();
        const data = {
            bodyType: avatarData.bodyType || 'blob',
            bodyColor: avatarData.bodyColor || '#FF6B9D',
            eyeType: avatarData.eyeType || 'big_round',
            mouthType: avatarData.mouthType || 'happy',
            headDecoration: avatarData.headDecoration || 'horns',
            decorationColor: avatarData.decorationColor || '#FFB347',
            pattern: avatarData.pattern || 'solid',
            patternColor: avatarData.patternColor || '#FF1493'
        };

        const arms = this.drawArms();
        const body = this.drawBody(data.bodyType, data.bodyColor);
        const pattern = this.drawPattern(data.bodyType, data.pattern, data.patternColor);
        const eyes = this.drawEyes(data.eyeType);
        const mouth = this.drawMouth(data.mouthType);
        const decoration = this.drawDecoration(data.headDecoration, data.decorationColor);

        this.monster.addChild(arms);
        this.monster.addChild(body);
        if (pattern) this.monster.addChild(pattern);
        this.monster.addChild(eyes);
        this.monster.addChild(mouth);
        if (decoration) this.monster.addChild(decoration);

        this.app.ticker.add(() => {
            this.monster.scale.y = 1 + Math.sin(Date.now() / 800) * 0.03;
        });
    }
}

function initNavbarAvatar() {
    if (typeof PIXI === 'undefined') {
        setTimeout(initNavbarAvatar, 100);
        return;
    }

    fetch('/api/avatar/', { credentials: 'include' })
        .then(response => response.json())
        .then(avatarData => {
            renderNavbarAvatar(avatarData);
        })
        .catch(error => {
            console.error('Error loading navbar avatar:', error);
        });

    async function renderNavbarAvatar(avatarData) {
        const container = document.getElementById('navbarAvatarIcon');
        if (!container) {
            return;
        }

        try {
            container.innerHTML = '';
            const app = new PIXI.Application({
                width: 120,
                height: 160,
                backgroundColor: 0xF5F7FA,
                antialias: true
            });
            const renderer = new NavbarMonsterRenderer(app, 120, 160);
            await renderer.init(container, 120, 160);
            renderer.render(avatarData);
            
            const canvas = renderer.app.canvas || renderer.app.view;
            if (canvas) {
                canvas.style.maxWidth = '100%';
                canvas.style.height = 'auto';
                canvas.style.borderRadius = '50%';
            }
        } catch (error) {
            console.error('Error rendering navbar avatar:', error);
        }
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initNavbarAvatar);
} else {
    initNavbarAvatar();
}
</script>
