{% load static %}
<!-- Avatar Display Component -->
<style>
    .avatar-display-card {
        text-align: center;
    }
    #avatarCanvas {
        border-radius: 15px;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        margin: 20px auto;
        box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    .customize-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        color: white;
        padding: 12px 30px;
        font-size: 16px;
        border-radius: 50px;
        font-weight: 600;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .customize-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.5);
        color: white;
    }
    .preview-canvas {
        border-radius: 15px;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        width: 100%;
        height: auto;
    }
    .form-label {
        font-weight: 600;
        color: #764ba2;
        margin-bottom: 8px;
    }
</style>

<div class="avatar-display-card">
    <h5 class="card-title mb-3">Your Monster Avatar</h5>
    
    <div id="avatarCanvas"></div>
    
    <button class="customize-btn mt-3" data-bs-toggle="modal" data-bs-target="#avatarCustomizerModal">
        ðŸŽ¨ Customize Avatar
    </button>
</div>

<!-- Avatar Customizer Modal -->
<div class="modal fade" id="avatarCustomizerModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Create Your Monster</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <!-- Live Preview -->
                    <div class="col-md-5">
                        <h6 class="text-center mb-3">Preview</h6>
                        <div id="previewCanvas" class="preview-canvas mx-auto"></div>
                    </div>
                    
                    <!-- Customization Form -->
                    <div class="col-md-7">
                        <form id="avatarForm">
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Body Shape</label>
                                    <select class="form-select" name="bodyType" id="bodyType">
                                        <option value="blob">Blob</option>
                                        <option value="round">Round</option>
                                        <option value="tall">Tall</option>
                                        <option value="wide">Wide</option>
                                        <option value="pear">Pear</option>
                                        <option value="bean">Bean</option>
                                    </select>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Body Color</label>
                                    <input type="color" class="form-control" name="bodyColor" id="bodyColor" value="#FF6B9D">
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Eyes</label>
                                    <select class="form-select" name="eyeType" id="eyeType">
                                        <option value="big_round">Big Round</option>
                                        <option value="small_dots">Small Dots</option>
                                        <option value="one_eye">One Eye</option>
                                        <option value="sleepy">Sleepy</option>
                                        <option value="googly">Googly</option>
                                        <option value="angry">Angry</option>
                                    </select>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Mouth</label>
                                    <select class="form-select" name="mouthType" id="mouthType">
                                        <option value="happy">Happy</option>
                                        <option value="toothy">Toothy</option>
                                        <option value="small">Small</option>
                                        <option value="big_smile">Big Smile</option>
                                        <option value="oh">Oh</option>
                                        <option value="silly">Silly</option>
                                    </select>
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Head Decoration</label>
                                    <select class="form-select" name="headDecoration" id="headDecoration">
                                        <option value="none">None</option>
                                        <option value="horns">Horns</option>
                                        <option value="antennae">Antennae</option>
                                        <option value="spikes">Spikes</option>
                                        <option value="ears">Ears</option>
                                        <option value="mohawk">Mohawk</option>
                                    </select>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Decoration Color</label>
                                    <input type="color" class="form-control" name="decorationColor" id="decorationColor" value="#FFB347">
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Pattern</label>
                                    <select class="form-select" name="pattern" id="pattern">
                                        <option value="solid">Solid</option>
                                        <option value="spots">Spots</option>
                                        <option value="stripes">Stripes</option>
                                        <option value="gradient">Gradient</option>
                                    </select>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Pattern Color</label>
                                    <input type="color" class="form-control" name="patternColor" id="patternColor" value="#FF1493">
                                </div>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="randomizeAvatar()">Randomize</button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveAvatar()">Save Avatar</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/pixi.js@7.2.4/dist/pixi.min.js"></script>
<script>
    // CSRF Token helper
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // ClassDojo-style Monster Renderer
    class MonsterRenderer {
        constructor(container, width = 300, height = 400) {
            this.app = new PIXI.Application({
                width: width,
                height: height,
                backgroundColor: 0xF5F7FA,
                antialias: true
            });
            container.appendChild(this.app.view);
            this.monster = new PIXI.Container();
            this.app.stage.addChild(this.monster);
        }

        drawBody(type, color) {
            const graphics = new PIXI.Graphics();
            const safeColor = color || '#FF6B9D';
            graphics.beginFill(parseInt(safeColor.replace('#', ''), 16));
            
            const centerX = this.app.view.width / 2;
            const centerY = this.app.view.height / 2;

            switch(type) {
                case 'blob':
                    // Irregular blob shape (ClassDojo style)
                    graphics.moveTo(centerX, centerY - 80);
                    graphics.bezierCurveTo(centerX + 90, centerY - 70, centerX + 100, centerY + 20, centerX + 80, centerY + 90);
                    graphics.bezierCurveTo(centerX + 50, centerY + 110, centerX - 50, centerY + 110, centerX - 80, centerY + 90);
                    graphics.bezierCurveTo(centerX - 100, centerY + 20, centerX - 90, centerY - 70, centerX, centerY - 80);
                    break;
                case 'round':
                    graphics.drawCircle(centerX, centerY, 90);
                    break;
                case 'tall':
                    graphics.drawEllipse(centerX, centerY, 60, 110);
                    break;
                case 'wide':
                    graphics.drawEllipse(centerX, centerY, 110, 70);
                    break;
                case 'pear':
                    graphics.moveTo(centerX, centerY - 70);
                    graphics.bezierCurveTo(centerX + 60, centerY - 60, centerX + 70, centerY, centerX + 90, centerY + 60);
                    graphics.bezierCurveTo(centerX + 80, centerY + 100, centerX - 80, centerY + 100, centerX - 90, centerY + 60);
                    graphics.bezierCurveTo(centerX - 70, centerY, centerX - 60, centerY - 60, centerX, centerY - 70);
                    break;
                case 'bean':
                    graphics.moveTo(centerX - 20, centerY - 90);
                    graphics.bezierCurveTo(centerX + 70, centerY - 80, centerX + 80, centerY - 20, centerX + 60, centerY + 50);
                    graphics.bezierCurveTo(centerX + 50, centerY + 90, centerX - 50, centerY + 90, centerX - 60, centerY + 50);
                    graphics.bezierCurveTo(centerX - 80, centerY - 20, centerX - 70, centerY - 80, centerX - 20, centerY - 90);
                    break;
            }
            graphics.endFill();
            
            return graphics;
        }

        drawPattern(bodyType, patternType, patternColor) {
            if (patternType === 'solid') return null;

            const graphics = new PIXI.Graphics();
            const centerX = this.app.view.width / 2;
            const centerY = this.app.view.height / 2;
            const safeColor = patternColor || '#FF1493';
            const color = parseInt(safeColor.replace('#', ''), 16);

            if (patternType === 'spots') {
                graphics.beginFill(color, 0.4);
                // Draw random-ish spots
                graphics.drawCircle(centerX - 30, centerY - 20, 15);
                graphics.drawCircle(centerX + 40, centerY - 10, 20);
                graphics.drawCircle(centerX - 20, centerY + 30, 18);
                graphics.drawCircle(centerX + 20, centerY + 40, 12);
                graphics.endFill();
            } else if (patternType === 'stripes') {
                graphics.beginFill(color, 0.3);
                for (let i = -80; i < 80; i += 30) {
                    graphics.drawRect(centerX - 100, centerY + i, 200, 15);
                }
                graphics.endFill();
            } else if (patternType === 'gradient') {
                // Create gradient overlay effect with circles
                graphics.beginFill(color, 0.15);
                graphics.drawCircle(centerX, centerY - 50, 60);
                graphics.endFill();
                
                graphics.beginFill(color, 0.1);
                graphics.drawCircle(centerX, centerY, 80);
                graphics.endFill();
                
                graphics.beginFill(color, 0.05);
                graphics.drawCircle(centerX, centerY + 40, 70);
                graphics.endFill();
            }

            return graphics;
        }

        drawEyes(type) {
            const container = new PIXI.Container();
            const centerX = this.app.view.width / 2;
            const centerY = this.app.view.height / 2;

            if (type === 'one_eye') {
                const eye = this.createEye(60, 60);
                eye.x = centerX;
                eye.y = centerY - 20;
                container.addChild(eye);
            } else if (type === 'big_round') {
                const leftEye = this.createEye(50, 50);
                leftEye.x = centerX - 40;
                leftEye.y = centerY - 30;
                
                const rightEye = this.createEye(50, 50);
                rightEye.x = centerX + 40;
                rightEye.y = centerY - 30;
                
                container.addChild(leftEye, rightEye);
            } else if (type === 'small_dots') {
                const leftEye = this.createEye(20, 20);
                leftEye.x = centerX - 30;
                leftEye.y = centerY - 20;
                
                const rightEye = this.createEye(20, 20);
                rightEye.x = centerX + 30;
                rightEye.y = centerY - 20;
                
                container.addChild(leftEye, rightEye);
            } else if (type === 'sleepy') {
                const leftEye = this.createSleepyEye();
                leftEye.x = centerX - 35;
                leftEye.y = centerY - 25;
                
                const rightEye = this.createSleepyEye();
                rightEye.x = centerX + 35;
                rightEye.y = centerY - 25;
                
                container.addChild(leftEye, rightEye);
            } else if (type === 'googly') {
                const leftEye = this.createGooglyEye();
                leftEye.x = centerX - 40;
                leftEye.y = centerY - 30;
                
                const rightEye = this.createGooglyEye();
                rightEye.x = centerX + 40;
                rightEye.y = centerY - 30;
                
                container.addChild(leftEye, rightEye);
            } else if (type === 'angry') {
                const leftEye = this.createAngryEye();
                leftEye.x = centerX - 40;
                leftEye.y = centerY - 30;
                
                const rightEye = this.createAngryEye();
                rightEye.x = centerX + 40;
                rightEye.y = centerY - 30;
                
                container.addChild(leftEye, rightEye);
            }

            return container;
        }

        createEye(width, height) {
            const eye = new PIXI.Graphics();
            eye.beginFill(0xFFFFFF);
            eye.drawEllipse(0, 0, width / 2, height / 2);
            eye.endFill();
            
            eye.beginFill(0x000000);
            eye.drawCircle(0, 0, width / 4);
            eye.endFill();
            
            eye.beginFill(0xFFFFFF);
            eye.drawCircle(width / 8, -width / 8, width / 10);
            eye.endFill();
            
            return eye;
        }

        createSleepyEye() {
            const eye = new PIXI.Graphics();
            eye.lineStyle(4, 0x000000);
            eye.arc(0, 0, 18, 0, Math.PI);
            return eye;
        }

        createGooglyEye() {
            const eye = new PIXI.Graphics();
            eye.beginFill(0xFFFFFF);
            eye.drawCircle(0, 0, 25);
            eye.endFill();
            
            eye.lineStyle(3, 0x000000);
            eye.drawCircle(0, 0, 25);
            
            // Offset pupil
            eye.beginFill(0x000000);
            eye.drawCircle(8, 5, 12);
            eye.endFill();
            
            return eye;
        }

        createAngryEye() {
            const eye = new PIXI.Graphics();
            eye.beginFill(0xFFFFFF);
            eye.drawEllipse(0, 0, 20, 15);
            eye.endFill();
            
            eye.beginFill(0xFF0000);
            eye.drawCircle(0, 0, 10);
            eye.endFill();
            
            // Angry eyebrow
            eye.lineStyle(4, 0x000000);
            eye.moveTo(-25, -20);
            eye.lineTo(5, -15);
            
            return eye;
        }

        drawMouth(type) {
            const graphics = new PIXI.Graphics();
            const centerX = this.app.view.width / 2;
            const centerY = this.app.view.height / 2;

            graphics.lineStyle(4, 0x000000);

            switch(type) {
                case 'happy':
                    graphics.beginFill(0x000000);
                    graphics.arc(centerX, centerY + 30, 40, 0, Math.PI);
                    graphics.endFill();
                    break;
                case 'toothy':
                    graphics.beginFill(0x000000);
                    graphics.arc(centerX, centerY + 30, 45, 0, Math.PI);
                    graphics.endFill();
                    // Teeth
                    graphics.beginFill(0xFFFFFF);
                    for (let i = -30; i <= 30; i += 15) {
                        graphics.drawRect(centerX + i - 5, centerY + 30, 10, 15);
                    }
                    graphics.endFill();
                    break;
                case 'small':
                    graphics.beginFill(0x000000);
                    graphics.drawCircle(centerX, centerY + 35, 15);
                    graphics.endFill();
                    break;
                case 'big_smile':
                    graphics.lineStyle(6, 0x000000);
                    graphics.arc(centerX, centerY + 20, 60, 0, Math.PI);
                    break;
                case 'oh':
                    graphics.beginFill(0x000000);
                    graphics.drawEllipse(centerX, centerY + 40, 20, 30);
                    graphics.endFill();
                    break;
                case 'silly':
                    graphics.beginFill(0x000000);
                    graphics.arc(centerX, centerY + 30, 35, 0, Math.PI);
                    graphics.endFill();
                    // Tongue
                    graphics.beginFill(0xFF69B4);
                    graphics.drawEllipse(centerX, centerY + 55, 20, 15);
                    graphics.endFill();
                    break;
            }

            return graphics;
        }

        drawDecoration(type, color) {
            if (type === 'none') return null;

            const graphics = new PIXI.Graphics();
            const centerX = this.app.view.width / 2;
            const centerY = this.app.view.height / 2;
            const safeColor = color || '#FFB347';
            const fillColor = parseInt(safeColor.replace('#', ''), 16);

            graphics.beginFill(fillColor);

            switch(type) {
                case 'horns':
                    // Left horn
                    graphics.moveTo(centerX - 60, centerY - 80);
                    graphics.lineTo(centerX - 80, centerY - 120);
                    graphics.lineTo(centerX - 40, centerY - 90);
                    graphics.closePath();
                    
                    // Right horn
                    graphics.moveTo(centerX + 60, centerY - 80);
                    graphics.lineTo(centerX + 80, centerY - 120);
                    graphics.lineTo(centerX + 40, centerY - 90);
                    graphics.closePath();
                    break;
                case 'antennae':
                    graphics.drawCircle(centerX - 50, centerY - 110, 12);
                    graphics.drawCircle(centerX + 50, centerY - 110, 12);
                    graphics.lineStyle(4, fillColor);
                    graphics.moveTo(centerX - 50, centerY - 98);
                    graphics.lineTo(centerX - 40, centerY - 70);
                    graphics.moveTo(centerX + 50, centerY - 98);
                    graphics.lineTo(centerX + 40, centerY - 70);
                    break;
                case 'spikes':
                    for (let i = -70; i <= 70; i += 20) {
                        graphics.moveTo(centerX + i - 8, centerY - 80);
                        graphics.lineTo(centerX + i, centerY - 110);
                        graphics.lineTo(centerX + i + 8, centerY - 80);
                        graphics.closePath();
                    }
                    break;
                case 'ears':
                    graphics.drawEllipse(centerX - 90, centerY - 40, 20, 35);
                    graphics.drawEllipse(centerX + 90, centerY - 40, 20, 35);
                    break;
                case 'mohawk':
                    for (let i = -40; i <= 40; i += 15) {
                        graphics.moveTo(centerX + i - 6, centerY - 80);
                        graphics.lineTo(centerX + i, centerY - 130 + Math.abs(i) / 2);
                        graphics.lineTo(centerX + i + 6, centerY - 80);
                        graphics.closePath();
                    }
                    break;
            }

            graphics.endFill();
            return graphics;
        }

        drawArms() {
            // Arms removed for cleaner look
            return new PIXI.Container();
        }

        render(avatarData) {
            // Clear previous monster
            this.monster.removeChildren();

            // Add defaults for missing fields
            const data = {
                bodyType: avatarData.bodyType || 'blob',
                bodyColor: avatarData.bodyColor || '#FF6B9D',
                eyeType: avatarData.eyeType || 'big_round',
                mouthType: avatarData.mouthType || 'happy',
                headDecoration: avatarData.headDecoration || 'horns',
                decorationColor: avatarData.decorationColor || '#FFB347',
                pattern: avatarData.pattern || 'solid',
                patternColor: avatarData.patternColor || '#FF1493'
            };

            // Draw in layers
            const arms = this.drawArms();
            const body = this.drawBody(data.bodyType, data.bodyColor);
            const pattern = this.drawPattern(data.bodyType, data.pattern, data.patternColor);
            const eyes = this.drawEyes(data.eyeType);
            const mouth = this.drawMouth(data.mouthType);
            const decoration = this.drawDecoration(data.headDecoration, data.decorationColor);

            this.monster.addChild(arms);
            this.monster.addChild(body);
            if (pattern) this.monster.addChild(pattern);
            this.monster.addChild(eyes);
            this.monster.addChild(mouth);
            if (decoration) this.monster.addChild(decoration);

            // Breathing animation
            this.app.ticker.add(() => {
                this.monster.scale.y = 1 + Math.sin(Date.now() / 800) * 0.03;
            });
        }
    }

    // Initialize main avatar display
    let mainRenderer = null;
    let previewRenderer = null;

    function initMainAvatar() {
        const container = document.getElementById('avatarCanvas');
        if (!container) return;
        
        mainRenderer = new MonsterRenderer(container, 300, 400);
        
        // Load avatar data
        fetch('/api/avatar/')
            .then(response => response.json())
            .then(data => {
                console.log('Avatar API response:', data);
                mainRenderer.render(data);
            })
            .catch(error => console.error('Error loading avatar:', error));
    }

    function initPreview() {
        const container = document.getElementById('previewCanvas');
        if (!container) return;
        
        container.innerHTML = '';  // Clear previous canvas
        previewRenderer = new MonsterRenderer(container, 250, 350);
    }

    function updatePreview() {
        const formData = {
            bodyType: document.getElementById('bodyType').value,
            bodyColor: document.getElementById('bodyColor').value,
            eyeType: document.getElementById('eyeType').value,
            mouthType: document.getElementById('mouthType').value,
            headDecoration: document.getElementById('headDecoration').value,
            decorationColor: document.getElementById('decorationColor').value,
            pattern: document.getElementById('pattern').value,
            patternColor: document.getElementById('patternColor').value
        };
        
        if (previewRenderer) {
            previewRenderer.render(formData);
        }
    }

    function saveAvatar() {
        const formData = {
            bodyType: document.getElementById('bodyType').value,
            bodyColor: document.getElementById('bodyColor').value,
            eyeType: document.getElementById('eyeType').value,
            mouthType: document.getElementById('mouthType').value,
            headDecoration: document.getElementById('headDecoration').value,
            decorationColor: document.getElementById('decorationColor').value,
            pattern: document.getElementById('pattern').value,
            patternColor: document.getElementById('patternColor').value
        };

        fetch('/api/avatar/save/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(formData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                location.reload();
            }
        })
        .catch(error => console.error('Error saving avatar:', error));
    }

    function randomizeAvatar() {
        fetch('/api/avatar/randomize/')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update form fields
                    document.getElementById('bodyType').value = data.avatar.bodyType;
                    document.getElementById('bodyColor').value = data.avatar.bodyColor;
                    document.getElementById('eyeType').value = data.avatar.eyeType;
                    document.getElementById('mouthType').value = data.avatar.mouthType;
                    document.getElementById('headDecoration').value = data.avatar.headDecoration;
                    document.getElementById('decorationColor').value = data.avatar.decorationColor;
                    document.getElementById('pattern').value = data.avatar.pattern;
                    document.getElementById('patternColor').value = data.avatar.patternColor;
                    
                    updatePreview();
                }
            })
            .catch(error => console.error('Error randomizing avatar:', error));
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
        initMainAvatar();
        
        const modal = document.getElementById('avatarCustomizerModal');
        if (modal) {
            modal.addEventListener('shown.bs.modal', function() {
                initPreview();
                
                // Load current avatar data
                fetch('/api/avatar/')
                    .then(response => response.json())
                    .then(data => {
                        console.log('Modal avatar data:', data);
                        document.getElementById('bodyType').value = data.bodyType || 'blob';
                        document.getElementById('bodyColor').value = data.bodyColor || '#FF6B9D';
                        document.getElementById('eyeType').value = data.eyeType || 'big_round';
                        document.getElementById('mouthType').value = data.mouthType || 'happy';
                        document.getElementById('headDecoration').value = data.headDecoration || 'horns';
                        document.getElementById('decorationColor').value = data.decorationColor || '#FFB347';
                        document.getElementById('pattern').value = data.pattern || 'solid';
                        document.getElementById('patternColor').value = data.patternColor || '#FF1493';
                        
                        updatePreview();
                    })
                    .catch(error => console.error('Error loading avatar in modal:', error));
            });

            // Live preview updates
            const formInputs = modal.querySelectorAll('select, input');
            formInputs.forEach(input => {
                input.addEventListener('change', updatePreview);
                input.addEventListener('input', updatePreview);
            });
        }
    });
</script>

    // Helper to convert hex to color
    function hexToColor(hex) {
        return parseInt(hex.replace('#', ''), 16);
    }

    // Create placeholder graphics
    function createBodyGraphic(color) {
        const graphics = new PIXI.Graphics();
        graphics.beginFill(color);
        graphics.drawCircle(0, 0, 40);
        graphics.endFill();
        return graphics;
    }

    function createEyeGraphic() {
        const graphics = new PIXI.Graphics();
        // Outer eye
        graphics.beginFill(0xFFFFFF);
        graphics.drawCircle(0, 0, 12);
        graphics.endFill();
        // Pupil
        graphics.beginFill(0x000000);
        graphics.drawCircle(0, 0, 6);
        graphics.endFill();
        // Shine effect
        graphics.beginFill(0xFFFFFF);
        graphics.drawCircle(-2, -2, 2);
        graphics.endFill();
        return graphics;
    }

    function createMouthGraphic(type) {
        const graphics = new PIXI.Graphics();
        graphics.lineStyle(2, 0x000000);
        
        switch (type) {
            case 'smile':
                graphics.arc(0, 0, 10, Math.PI, 0);
                break;
            case 'grin':
                graphics.arc(0, 0, 15, Math.PI, 0);
                break;
            case 'open':
                graphics.beginFill(0xFF69B4);
                graphics.drawEllipse(0, 5, 8, 12);
                graphics.endFill();
                graphics.lineStyle(2, 0x000000);
                graphics.drawEllipse(0, 5, 8, 12);
                break;
            case 'neutral':
                graphics.moveTo(-8, 0);
                graphics.lineTo(8, 0);
                break;
            case 'tongue':
                graphics.beginFill(0xFF1493);
                graphics.drawEllipse(0, 10, 6, 10);
                graphics.endFill();
                graphics.lineStyle(2, 0x000000);
                graphics.arc(0, 0, 10, Math.PI, 0);
                break;
            default:
                graphics.arc(0, 0, 10, Math.PI, 0);
        }
        
        return graphics;
    }

    function createAccessoryGraphic(type) {
        if (type === 'none') return null;

        const graphics = new PIXI.Graphics();
        
        switch (type) {
            case 'cap':
                graphics.beginFill(0xFF0000);
                graphics.moveTo(-30, -40);
                graphics.lineTo(30, -40);
                graphics.lineTo(20, -50);
                graphics.lineTo(-20, -50);
                graphics.closePath();
                graphics.endFill();
                break;
            case 'hat':
                graphics.beginFill(0x8B4513);
                graphics.moveTo(-40, -45);
                graphics.lineTo(40, -45);
                graphics.lineTo(35, -65);
                graphics.lineTo(-35, -65);
                graphics.closePath();
                graphics.endFill();
                break;
            case 'crown':
                graphics.beginFill(0xFFD700);
                // Draw crown as a simple shape
                graphics.moveTo(-20, -40);
                graphics.lineTo(-10, -55);
                graphics.lineTo(0, -45);
                graphics.lineTo(10, -55);
                graphics.lineTo(20, -40);
                graphics.lineTo(0, -35);
                graphics.closePath();
                graphics.endFill();
                break;
            case 'glasses':
                graphics.lineStyle(3, 0x000000);
                graphics.drawCircle(-10, -5, 8);
                graphics.drawCircle(10, -5, 8);
                graphics.moveTo(0, -5);
                graphics.lineTo(0, -5);
                break;
            case 'bow':
                graphics.beginFill(0xFF69B4);
                graphics.drawCircle(-15, -45, 8);
                graphics.drawCircle(15, -45, 8);
                graphics.endFill();
                graphics.lineStyle(2, 0xFF1493);
                graphics.moveTo(-15, -45);
                graphics.lineTo(15, -45);
                break;
        }
        
        return graphics;
    }

    // Initialize PIXI
    const container = document.getElementById('avatar-container');
    if (!container) {
        console.error('Avatar container not found');
        return;
    }
    
    const app = new PIXI.Application({
        width: 200,
        height: 200,
        backgroundAlpha: 0,
        antialias: true,
        resolution: 1
    });

    // Clear container and add canvas
    container.innerHTML = '';
    const canvas = app.view;
    canvas.style.width = '200px';
    canvas.style.height = '200px';
    canvas.style.display = 'block';
    container.appendChild(canvas);
    console.log('Canvas appended, starting rendering');


    // Create monster container
    const monster = new PIXI.Container();
    monster.x = 100;
    monster.y = 100;
    app.stage.addChild(monster);

    // Create avatar parts
    const primaryColor = hexToColor(avatarData.primaryColor);
    const accentColor = hexToColor(avatarData.accentColor);

    // Body
    const body = createBodyGraphic(primaryColor);
    body.y = 5;

    // Eyes
    const eyesContainer = new PIXI.Container();
    eyesContainer.y = -15;
    const leftEye = createEyeGraphic();
    leftEye.x = -15;
    const rightEye = createEyeGraphic();
    rightEye.x = 15;
    eyesContainer.addChild(leftEye, rightEye);

    // Mouth
    const mouth = createMouthGraphic(avatarData.mouthType);
    mouth.y = 20;

    // Arms
    const armsContainer = new PIXI.Container();
    const leftArm = new PIXI.Graphics();
    leftArm.beginFill(accentColor);
    leftArm.drawCircle(0, 0, 8);
    leftArm.endFill();
    leftArm.x = -50;
    armsContainer.addChild(leftArm);

    const rightArm = new PIXI.Graphics();
    rightArm.beginFill(accentColor);
    rightArm.drawCircle(0, 0, 8);
    rightArm.endFill();
    rightArm.x = 50;
    armsContainer.addChild(rightArm);

    // Accessory
    const accessory = createAccessoryGraphic(avatarData.accessory);

    // Add all parts to monster
    monster.addChild(body, eyesContainer, mouth, armsContainer);
    if (accessory) {
        monster.addChild(accessory);
    }

    // Animation: "alive" effect
    let time = 0;
    app.ticker.add(() => {
        time += 0.01;

        // Breathing/bouncing effect
        monster.scale.y = 1 + Math.sin(time * 2) * 0.03;
        monster.rotation = Math.sin(time * 1.5) * 0.02;

        // Eyes blinking
        const blinkCycle = (Math.sin(time * 0.5) + 1) / 2;
        eyesContainer.scale.y = blinkCycle > 0.9 || blinkCycle < 0.1 ? 0.1 : 1;

        // Arms wave
        leftArm.rotation = Math.sin(time * 1.5) * 0.4 - 0.2;
        rightArm.rotation = Math.sin(time * 1.5 + Math.PI) * 0.4 + 0.2;
    });
    
    console.log('Avatar rendering complete');
}

// Call render function immediately
renderAvatar();

// Helper function to get CSRF cookie
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Listen for modal open and load avatar customizer
const avatarModal = document.getElementById('avatarCustomizerModal');
if (avatarModal) {
    avatarModal.addEventListener('show.bs.modal', function() {
        const container = document.getElementById('avatarCustomizerContainer');
        if (!container) {
            console.error('Avatar customizer container not found');
            return;
        }
        
        if (container.querySelector('.avatar-customizer-form')) {
            return; // Already loaded
        }
        
        console.log('Modal opened, fetching avatar data...');
        
        // Fetch current avatar data
        fetch('/api/avatar/', {
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
        .then(response => {
            console.log('Avatar API response:', response.status);
            if (!response.ok) {
                throw new Error('Failed to fetch avatar data: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            console.log('Avatar data loaded:', data);
        // Create customizer form
        const html = `
            <div class="avatar-customizer-form">
                <div class="row">
                    <div class="col-md-6">
                        <h6 class="mb-3">Live Preview</h6>
                        <div id="avatarPreviewContainer" style="width: 250px; height: 250px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 16px; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center;">
                            <!-- Live preview will render here -->
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6 class="mb-3">Customize</h6>
                        <form id="avatarForm">
                            <div class="mb-3">
                                <label class="form-label">Body Type</label>
                                <select class="form-select form-select-sm" name="body_type" id="bodyType">
                                    <option value="round_blue" ${data.bodyType === 'round_blue' ? 'selected' : ''}>Round Blue</option>
                                    <option value="round_pink" ${data.bodyType === 'round_pink' ? 'selected' : ''}>Round Pink</option>
                                    <option value="round_green" ${data.bodyType === 'round_green' ? 'selected' : ''}>Round Green</option>
                                    <option value="round_yellow" ${data.bodyType === 'round_yellow' ? 'selected' : ''}>Round Yellow</option>
                                    <option value="square_purple" ${data.bodyType === 'square_purple' ? 'selected' : ''}>Square Purple</option>
                                    <option value="square_orange" ${data.bodyType === 'square_orange' ? 'selected' : ''}>Square Orange</option>
                                </select>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Eye Type</label>
                                <select class="form-select form-select-sm" name="eye_type" id="eyeType">
                                    <option value="big_happy" ${data.eyeType === 'big_happy' ? 'selected' : ''}>Big Happy</option>
                                    <option value="big_sleepy" ${data.eyeType === 'big_sleepy' ? 'selected' : ''}>Big Sleepy</option>
                                    <option value="small_angry" ${data.eyeType === 'small_angry' ? 'selected' : ''}>Small Angry</option>
                                    <option value="round_confused" ${data.eyeType === 'round_confused' ? 'selected' : ''}>Round Confused</option>
                                    <option value="star_sparkly" ${data.eyeType === 'star_sparkly' ? 'selected' : ''}>Star Sparkly</option>
                                </select>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Mouth Type</label>
                                <select class="form-select form-select-sm" name="mouth_type" id="mouthType">
                                    <option value="smile" ${data.mouthType === 'smile' ? 'selected' : ''}>Smile</option>
                                    <option value="grin" ${data.mouthType === 'grin' ? 'selected' : ''}>Big Grin</option>
                                    <option value="open" ${data.mouthType === 'open' ? 'selected' : ''}>Open</option>
                                    <option value="neutral" ${data.mouthType === 'neutral' ? 'selected' : ''}>Neutral</option>
                                    <option value="tongue" ${data.mouthType === 'tongue' ? 'selected' : ''}>Tongue Out</option>
                                </select>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Accessory</label>
                                <select class="form-select form-select-sm" name="accessory" id="accessory">
                                    <option value="none" ${data.accessory === 'none' ? 'selected' : ''}>None</option>
                                    <option value="cap" ${data.accessory === 'cap' ? 'selected' : ''}>Cap</option>
                                    <option value="hat" ${data.accessory === 'hat' ? 'selected' : ''}>Hat</option>
                                    <option value="crown" ${data.accessory === 'crown' ? 'selected' : ''}>Crown</option>
                                    <option value="glasses" ${data.accessory === 'glasses' ? 'selected' : ''}>Glasses</option>
                                    <option value="bow" ${data.accessory === 'bow' ? 'selected' : ''}>Bow</option>
                                </select>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-6">
                                    <label class="form-label">Primary Color</label>
                                    <input type="color" class="form-control form-control-color w-100" name="primary_color" id="primaryColor" value="${data.primaryColor}" title="Choose primary color">
                                </div>
                                <div class="col-6">
                                    <label class="form-label">Accent Color</label>
                                    <input type="color" class="form-control form-control-color w-100" name="accent_color" id="accentColor" value="${data.accentColor}" title="Choose accent color">
                                </div>
                            </div>
                            
                            <div class="d-flex gap-2 justify-content-between mt-4">
                                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Close</button>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-info btn-sm" onclick="randomizeAvatar()">ðŸŽ² Randomize</button>
                                    <button type="submit" class="btn btn-primary btn-sm">ðŸ’¾ Save Avatar</button>
                                </div>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        `;
        
        container.innerHTML = html;
        
        // Initialize live preview
        initAvatarPreview(data);
        
        // Attach form submit handler
        document.getElementById('avatarForm').addEventListener('submit', saveAvatar);
        
        // Add change listeners to all form inputs for live preview
        ['bodyType', 'eyeType', 'mouthType', 'accessory', 'primaryColor', 'accentColor'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', updatePreview);
                element.addEventListener('input', updatePreview);
            } else {
                console.warn('Element not found:', id);
            }
        });
    })
    .catch(error => {
        console.error('Error loading avatar data:', error);
        container.innerHTML = '<div class="alert alert-danger"><strong>Error loading avatar customizer:</strong><br>' + error.message + '</div>';
    });
    });
} else {
    console.error('Avatar customizer modal element not found in DOM');
}

function saveAvatar(e) {
    e.preventDefault();
    
    const formData = {
        body_type: document.getElementById('bodyType').value,
        eye_type: document.getElementById('eyeType').value,
        mouth_type: document.getElementById('mouthType').value,
        accessory: document.getElementById('accessory').value,
        primary_color: document.getElementById('primaryColor').value,
        accent_color: document.getElementById('accentColor').value
    };
    
    fetch('/api/avatar/save/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(formData)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to save avatar');
        }
        return response.json();
    })
    .then(data => {
        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('avatarCustomizerModal'));
        modal.hide();
        
        // Reload page to see updated avatar
        setTimeout(() => {
            window.location.reload();
        }, 500);
    })
    .catch(error => {
        console.error('Error saving avatar:', error);
        alert('Error saving avatar. Please try again.');
    });
}

function randomizeAvatar() {
    fetch('/api/avatar/randomize/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken')
        }
    })
    .then(response => response.json())
    .then(data => {
        // Update form fields with randomized values
        // API returns camelCase keys from avatar.to_dict()
        document.getElementById('bodyType').value = data.bodyType;
        document.getElementById('eyeType').value = data.eyeType;
        document.getElementById('mouthType').value = data.mouthType;
        document.getElementById('accessory').value = data.accessory;
        document.getElementById('primaryColor').value = data.primaryColor;
        document.getElementById('accentColor').value = data.accentColor;
        
        // Update preview
        updatePreview();
    })
    .catch(error => console.error('Error randomizing avatar:', error));
}

// Avatar preview globals
let previewApp = null;
let previewMonster = null;
let previewParts = {};

function initAvatarPreview(data) {
    if (!window.PIXI) {
        console.error('PixiJS not loaded for preview');
        return;
    }
    
    const PIXI = window.PIXI;
    const container = document.getElementById('avatarPreviewContainer');
    
    if (!container) {
        console.error('Preview container not found');
        return;
    }
    
    // Create PIXI app for preview
    previewApp = new PIXI.Application({
        width: 250,
        height: 250,
        backgroundAlpha: 0,
        antialias: true,
        resolution: 1
    });
    
    container.innerHTML = '';
    container.appendChild(previewApp.view);
    
    // Create monster container
    previewMonster = new PIXI.Container();
    previewMonster.x = 125;
    previewMonster.y = 125;
    previewApp.stage.addChild(previewMonster);
    
    // Initial render
    updatePreview();
    
    // Add animation
    let time = 0;
    previewApp.ticker.add(() => {
        if (!previewMonster || !previewParts.eyesContainer) return;
        
        time += 0.01;
        
        // Breathing/bouncing effect
        previewMonster.scale.y = 1 + Math.sin(time * 2) * 0.03;
        previewMonster.rotation = Math.sin(time * 1.5) * 0.02;
        
        // Eyes blinking
        const blinkCycle = (Math.sin(time * 0.5) + 1) / 2;
        previewParts.eyesContainer.scale.y = blinkCycle > 0.9 || blinkCycle < 0.1 ? 0.1 : 1;
        
        // Arms wave
        if (previewParts.leftArm && previewParts.rightArm) {
            previewParts.leftArm.rotation = Math.sin(time * 1.5) * 0.4 - 0.2;
            previewParts.rightArm.rotation = Math.sin(time * 1.5 + Math.PI) * 0.4 + 0.2;
        }
    });
}

function updatePreview() {
    if (!previewApp || !previewMonster || !window.PIXI) return;
    
    const PIXI = window.PIXI;
    
    // Get current form values
    const avatarData = {
        bodyType: document.getElementById('bodyType').value,
        eyeType: document.getElementById('eyeType').value,
        mouthType: document.getElementById('mouthType').value,
        accessory: document.getElementById('accessory').value,
        primaryColor: document.getElementById('primaryColor').value,
        accentColor: document.getElementById('accentColor').value
    };
    
    // Helper to convert hex to color
    function hexToColor(hex) {
        return parseInt(hex.replace('#', ''), 16);
    }
    
    // Create graphics functions (same as main avatar)
    function createBodyGraphic(color) {
        const graphics = new PIXI.Graphics();
        graphics.beginFill(color);
        graphics.drawCircle(0, 0, 50);
        graphics.endFill();
        return graphics;
    }
    
    function createEyeGraphic() {
        const graphics = new PIXI.Graphics();
        graphics.beginFill(0xFFFFFF);
        graphics.drawCircle(0, 0, 15);
        graphics.endFill();
        graphics.beginFill(0x000000);
        graphics.drawCircle(0, 0, 8);
        graphics.endFill();
        graphics.beginFill(0xFFFFFF);
        graphics.drawCircle(-3, -3, 3);
        graphics.endFill();
        return graphics;
    }
    
    function createMouthGraphic(type) {
        const graphics = new PIXI.Graphics();
        graphics.lineStyle(3, 0x000000);
        
        switch (type) {
            case 'smile':
                graphics.arc(0, 0, 15, Math.PI, 0);
                break;
            case 'grin':
                graphics.arc(0, 0, 20, Math.PI, 0);
                break;
            case 'open':
                graphics.beginFill(0xFF69B4);
                graphics.drawEllipse(0, 5, 10, 15);
                graphics.endFill();
                graphics.lineStyle(3, 0x000000);
                graphics.drawEllipse(0, 5, 10, 15);
                break;
            case 'neutral':
                graphics.moveTo(-10, 0);
                graphics.lineTo(10, 0);
                break;
            case 'tongue':
                graphics.beginFill(0xFF1493);
                graphics.drawEllipse(0, 15, 8, 12);
                graphics.endFill();
                graphics.lineStyle(3, 0x000000);
                graphics.arc(0, 0, 15, Math.PI, 0);
                break;
            default:
                graphics.arc(0, 0, 15, Math.PI, 0);
        }
        
        return graphics;
    }
    
    function createAccessoryGraphic(type) {
        if (type === 'none') return null;
        
        const graphics = new PIXI.Graphics();
        
        switch (type) {
            case 'cap':
                graphics.beginFill(0xFF0000);
                graphics.moveTo(-35, -50);
                graphics.lineTo(35, -50);
                graphics.lineTo(25, -60);
                graphics.lineTo(-25, -60);
                graphics.closePath();
                graphics.endFill();
                break;
            case 'hat':
                graphics.beginFill(0x8B4513);
                graphics.moveTo(-45, -55);
                graphics.lineTo(45, -55);
                graphics.lineTo(40, -75);
                graphics.lineTo(-40, -75);
                graphics.closePath();
                graphics.endFill();
                break;
            case 'crown':
                graphics.beginFill(0xFFD700);
                // Draw crown as a simple shape (preview version)
                graphics.moveTo(-25, -50);
                graphics.lineTo(-12, -68);
                graphics.lineTo(0, -55);
                graphics.lineTo(12, -68);
                graphics.lineTo(25, -50);
                graphics.lineTo(0, -45);
                graphics.closePath();
                graphics.endFill();
                break;
            case 'glasses':
                graphics.lineStyle(4, 0x000000);
                graphics.drawCircle(-12, -5, 10);
                graphics.drawCircle(12, -5, 10);
                graphics.moveTo(0, -5);
                graphics.lineTo(0, -5);
                break;
            case 'bow':
                graphics.beginFill(0xFF69B4);
                graphics.drawCircle(-20, -55, 10);
                graphics.drawCircle(20, -55, 10);
                graphics.endFill();
                graphics.lineStyle(3, 0xFF1493);
                graphics.moveTo(-20, -55);
                graphics.lineTo(20, -55);
                break;
        }
        
        return graphics;
    }
    
    // Clear existing monster parts
    previewMonster.removeChildren();
    previewParts = {};
    
    // Create new parts
    const primaryColor = hexToColor(avatarData.primaryColor);
    const accentColor = hexToColor(avatarData.accentColor);
    
    // Body
    const body = createBodyGraphic(primaryColor);
    body.y = 5;
    
    // Eyes
    const eyesContainer = new PIXI.Container();
    eyesContainer.y = -20;
    const leftEye = createEyeGraphic();
    leftEye.x = -20;
    const rightEye = createEyeGraphic();
    rightEye.x = 20;
    eyesContainer.addChild(leftEye, rightEye);
    
    // Mouth
    const mouth = createMouthGraphic(avatarData.mouthType);
    mouth.y = 25;
    
    // Arms
    const armsContainer = new PIXI.Container();
    const leftArm = new PIXI.Graphics();
    leftArm.beginFill(accentColor);
    leftArm.drawCircle(0, 0, 10);
    leftArm.endFill();
    leftArm.x = -60;
    leftArm.y = 0;
    
    const rightArm = new PIXI.Graphics();
    rightArm.beginFill(accentColor);
    rightArm.drawCircle(0, 0, 10);
    rightArm.endFill();
    rightArm.x = 60;
    rightArm.y = 0;
    
    armsContainer.addChild(leftArm, rightArm);
    
    // Accessory
    const accessory = createAccessoryGraphic(avatarData.accessory);
    
    // Add all parts to monster
    previewMonster.addChild(body, eyesContainer, mouth, armsContainer);
    if (accessory) {
        previewMonster.addChild(accessory);
    }
    
    // Store references for animation
    previewParts = {
        body,
        eyesContainer,
        mouth,
        leftArm,
        rightArm,
        accessory
    };
}
</script>

<style>
.avatar-display-card {
    text-align: center;
    padding: 1rem;
}

#avatar-container {
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    margin: 0 auto;
    width: 200px;
    height: 200px;
    min-width: 200px;
    min-height: 200px;
}

#avatar-container canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
}

.avatar-info {
    text-align: left;
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    margin: 1rem 0;
}

.avatar-info p {
    font-size: 0.9rem;
}
</style>
